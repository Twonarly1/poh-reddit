"use strict";
// Copyright (c) 2020,2021,2022, StepZen, Inc.
Object.defineProperty(exports, "__esModule", { value: true });
const chalk = require("chalk");
const fs = require("fs-extra");
const path = require("path");
const inquirer = require("inquirer");
const command_1 = require("@oclif/command");
const errors_1 = require("@oclif/errors");
const transpiler_1 = require("@stepzen/transpiler");
const core_1 = require("@oclif/core");
const generate_1 = require("../generate");
const utils_1 = require("../shared/utils");
const helpers_1 = require("../generate/helpers");
const curl2sdl_1 = require("../generate/curl2sdl");
const curl_parser_1 = require("../shared/curl-parser");
const zen_command_1 = require("../shared/zen-command");
const graphql2sdl_1 = require("../generate/graphql2sdl");
const sql2sdl_1 = require("../generate/sql2sdl");
const constants_1 = require("../shared/constants");
const path_params_parser_1 = require("../shared/path-params-parser");
const header_params_parser_1 = require("../shared/header-params-parser");
const header_1 = require("../shared/header");
const configuration_1 = require("../shared/configuration");
class Import extends zen_command_1.default {
    async run() {
        const { args, argv, flags } = this.parseWorkaround();
        // Get a list of schemas you're asking for
        const schema = (0, helpers_1.getSchema)(args.schema);
        // Get or create a StepZen workspace (possibly interactive)
        const workspace = await this.ensureStepZenWorkspace({ directory: flags.dir });
        // Define a sane onConflict behaviour (possibly interactive)
        const onConflict = await this.ensureOnConflictBehavior(workspace, schema, flags);
        this.warnAboutIgnoredFlags(schema, flags);
        // Common options for all import schemas
        const commonOptions = {
            name: flags.name,
            source: workspace.schema,
            onConflict,
        };
        // Select an import execution flow:
        //  - v1 (deprecated) through the `generator-engines` cloud function
        //  - v2 (default) directly call the DB and REST introspection service APIs
        const useGeneratorEngines = (0, utils_1.getFeatureFlag)(constants_1.USE_GENERATOR_ENGINES);
        let importFn = undefined;
        switch (schema) {
            case 'curl':
                importFn = () => this.importCurl(argv, flags, commonOptions);
                break;
            case 'graphql':
                importFn = () => this.importGraphQL(argv, flags, commonOptions);
                break;
            case 'mysql':
            case 'postgresql':
                importFn = useGeneratorEngines
                    ? () => this.importFromGeneratorEngines(schema, flags, commonOptions)
                    : () => this.importSql(schema, flags, commonOptions);
                break;
            default:
                if (useGeneratorEngines) {
                    importFn = () => this.importFromGeneratorEngines(schema, flags, commonOptions);
                }
                else {
                    throw new errors_1.CLIError(`Cannot find the schema ${schema}`);
                }
        }
        const result = await importFn();
        // Housekeeping
        fs.copySync(result, workspace.schema);
        fs.removeSync(result);
        // Nice message
        this.log(chalk.green(`Successfully imported schema ${chalk.bold(schema)} from StepZen`));
    }
    async importCurl(argv, flags, commonOptions) {
        const headers = this.parseHeaderFlags(flags.header, flags['header-param']);
        this.log(chalk.yellow(`NOTE: ${chalk.bold('stepzen import curl')} is a ${chalk.bold('new')} feature.`));
        this.log(chalk.yellow('If you have any issues, please check if they have been addressed ' +
            'in the latest version, or reach out to StepZen on Discord: ' +
            constants_1.STEPZEN_DISCORD_URL));
        let curl2sdlOptions;
        const curlFlagValues = {
            queryName: flags['query-name'],
            rootType: flags['query-type'],
            typePrefix: flags.prefix,
            pathParams: flags['path-params'],
        };
        if (argv.length === 1) {
            // no parameters given: start an interactive prompt
            console.log();
            console.log('This command introspects the response of a REST endpoint and generates' +
                ' a GraphQL schema allowing you to access this endpoint through your ' +
                'StepZen API. curl syntax is supported so that you copy and paste a ' +
                'curl command instead of the URL.');
            console.log();
            const interactiveOptions = await (0, curl2sdl_1.askCurlQuestions)(curlFlagValues);
            curl2sdlOptions = Object.assign(Object.assign(Object.assign({}, commonOptions), interactiveOptions), { 
                // include boths headers passed via flags and headers entered interactively
                headers: headers.concat(interactiveOptions.curlArgs.headers) });
        }
        else {
            // run non-interactively
            const argsOrError = (0, curl_parser_1.parseCurlArgv)(argv);
            if ('error' in argsOrError) {
                throw new errors_1.CLIError(argsOrError.error);
            }
            const parsedPathParamsOrError = (0, path_params_parser_1.parsePathParamsPattern)(argsOrError.url, flags['path-params']);
            if ('error' in parsedPathParamsOrError) {
                throw new errors_1.CLIError(parsedPathParamsOrError.error);
            }
            const maybeDuplicateParamsMessage = (0, curl2sdl_1.makeDuplicateParamsMessage)(headers, parsedPathParamsOrError, argsOrError.url);
            if (maybeDuplicateParamsMessage) {
                throw new errors_1.CLIError(maybeDuplicateParamsMessage);
            }
            curl2sdlOptions = Object.assign(Object.assign(Object.assign({}, commonOptions), curlFlagValues), { pathParams: parsedPathParamsOrError, headers: headers, curlArgs: argsOrError });
        }
        core_1.CliUx.ux.action.start('Starting');
        const configuration = await (0, configuration_1.readConfiguration)();
        const resultOrError = await (0, curl2sdl_1.curl2sdl)(curl2sdlOptions, configuration);
        core_1.CliUx.ux.action.stop();
        if ('error' in resultOrError) {
            this.log('A problem occured while processing your import. ' +
                'Please check that the given cURL command is valid.');
            this.log(resultOrError.error);
            this.exit();
        }
        return resultOrError.outPath;
    }
    async importGraphQL(argv, flags, commonOptions) {
        const headers = this.parseHeaderFlags(flags.header, flags['header-param']);
        let graphql2sdlOptions;
        const graphqlFlagValues = {
            typePrefix: flags.prefix,
        };
        if (argv.length === 1) {
            // no parameters given: start an interactive prompt
            const interactiveOptions = await (0, graphql2sdl_1.askGraphQLQuestions)(graphqlFlagValues);
            graphql2sdlOptions = Object.assign(Object.assign(Object.assign({}, commonOptions), interactiveOptions), { 
                // include boths headers passed via flags and headers entered interactively
                headers: headers.concat(interactiveOptions.headers) });
        }
        else {
            // run non-interactively
            graphql2sdlOptions = Object.assign(Object.assign(Object.assign({}, commonOptions), graphqlFlagValues), { endpoint: argv[1], headers: headers });
        }
        core_1.CliUx.ux.action.start('Starting');
        const configuration = await (0, configuration_1.readConfiguration)();
        const resultOrError = await (0, graphql2sdl_1.graphql2sdl)(graphql2sdlOptions, configuration);
        core_1.CliUx.ux.action.stop();
        if ('error' in resultOrError) {
            this.log('A problem occured while processing your import.');
            this.log(resultOrError.error);
            this.exit();
        }
        return resultOrError.outPath;
    }
    async importSql(schema, flags, fixedOptions) {
        let sql2sdlOptions;
        const sqlFlagValues = this.getSqlOptionsFromFlags(flags);
        if (sqlFlagValues.host !== undefined &&
            sqlFlagValues.database !== undefined &&
            sqlFlagValues.user !== undefined &&
            sqlFlagValues.password !== undefined) {
            // run non-interactively
            sql2sdlOptions = Object.assign(Object.assign(Object.assign({}, fixedOptions), sqlFlagValues), sqlFlagValues);
        }
        else {
            // one or more required parameters are missing: start an interactive prompt
            const interactiveOptions = await (0, sql2sdl_1.askSqlQuestions)(schema, sqlFlagValues);
            sql2sdlOptions = Object.assign(Object.assign(Object.assign({}, fixedOptions), interactiveOptions), { include: sqlFlagValues.include });
        }
        core_1.CliUx.ux.action.start('Starting');
        const configuration = await (0, configuration_1.readConfiguration)();
        const resultOrError = await (0, sql2sdl_1.sql2sdl)(schema, sql2sdlOptions, configuration);
        core_1.CliUx.ux.action.stop();
        if ('error' in resultOrError) {
            this.log('A problem occured while processing your import. ' +
                'Please check that the given database details are valid.');
            this.log(resultOrError.error);
            this.exit();
        }
        return resultOrError.outPath;
    }
    async importFromGeneratorEngines(schema, flags, fixedOptions) {
        let preAnswered = {};
        if (schema === 'mysql' || schema === 'postgresql') {
            preAnswered = this.getSqlOptionsFromFlags(flags);
            if (Object.prototype.hasOwnProperty.call(preAnswered, 'linkTypes')) {
                preAnswered.linkTypes = preAnswered.linkTypes ? 'Yes' : 'No';
            }
        }
        // Let's go!
        const result = await (0, generate_1.default)(Object.assign(Object.assign({}, fixedOptions), { schema,
            preAnswered }));
        // Validate
        await (0, transpiler_1.validate)(result, {
            extensions: await (0, utils_1.getStepZenExtensions)(),
        });
        return result;
    }
    async ensureOnConflictBehavior(workspace, schema, flags) {
        const detectNameConflicts = (0, utils_1.getFeatureFlag)(constants_1.DETECT_NAME_CONFLICTS);
        if (!detectNameConflicts) {
            return 'append';
        }
        const name = flags.name || schema;
        const hasConflict = fs.existsSync(path.join(workspace.schema, name));
        if (!hasConflict) {
            return 'append';
        }
        // No `--name` is given (i.e. naming is automatic)
        // Using the default name is going to lead to a conflict, and it should
        // be resolved by inventing a new unique name for the new schema.
        if (!flags.name) {
            return 'append';
        }
        // `--name` is given and (i.e. naming is namaged by the user)
        // There is a naming conflict.
        // The user has explicitly asked to overwrite the existing schema.
        if (flags.overwrite) {
            return 'overwrite';
        }
        // `--name` is given and (i.e. naming is namaged by the user)
        // There is a naming conflict.
        // The user has NOT given an explicit permission to overwrite the existing
        // schema.
        // In an interactive mode the CLI asks them for a confirmation.
        // In a non-interactive mode the CLI throws an error.
        if (flags['non-interactive']) {
            throw new errors_1.CLIError(`A schema named ${chalk.bold(flags.name)} already exists in this workspace. Add an ${chalk.bold('--overwrite')} flag to overwrite it.`);
        }
        this.log(`A schema named ${chalk.bold(flags.name)} already exists in this workspace. Would you like to overwrite it?`);
        const answers = await inquirer.prompt([
            {
                name: 'overwrite',
                type: 'confirm',
                default: false,
                message: `Overwrite ${flags.name}?`,
            },
        ]);
        if (answers.overwrite) {
            return 'overwrite';
        }
        this.exit();
    }
    // notify the user about any ignored flags
    warnAboutIgnoredFlags(schema, usedFlags) {
        Import.flagsForSchemas.forEach(({ flags, schemas }) => {
            if (!schemas.includes(schema)) {
                Object.keys(flags).forEach(flag => {
                    if (Object.prototype.hasOwnProperty.call(usedFlags, flag)) {
                        this.log(chalk.gray(`The ${chalk.bold(`--${flag}`)} flag only applies when importing ${schemas
                            .map(schema => chalk.bold(schema))
                            .join(', ')}. It will be ignored now.`));
                    }
                });
            }
        });
    }
    // Correct the value for the 'header-param' flag to work around the oclif's
    // parser issue with multi-value flags: https://github.com/oclif/oclif/issues/261
    parseWorkaround() {
        const argv = this.argv;
        const parsed = this.parse(Import, argv);
        const fixFlag = (flag) => {
            if (parsed.flags[flag]) {
                // Every ['--flag', value] pair in the argv array should match
                // only one value in the flag's value list.
                const matchedIndices = new Set();
                // For each value in the flag's value list, find the original
                // ['--flag', value] pair in the argv array.
                for (let i = 0; i < parsed.flags[flag].length; i++) {
                    const value = parsed.flags[flag][i];
                    const flagIdx = argv.findIndex((arg, idx) => {
                        const spaceDelimMatch = (arg === `--${flag}` ||
                            (Import.flags[flag].char &&
                                arg === `-${Import.flags[flag].char}`)) &&
                            idx < argv.length &&
                            argv[idx + 1] === value;
                        const eqlDelimMatch = arg === `--${flag}=${value}`;
                        return ((spaceDelimMatch || eqlDelimMatch) && !matchedIndices.has(idx));
                    });
                    // If not found, that means the given value was associated with the
                    // `flag` incorrectly. In that case, it's moved from `flags` to `argv` in
                    // the parsed output.
                    if (flagIdx === -1) {
                        parsed.flags[flag].splice(i, 1);
                        i -= 1; // compensate for the .splice() call above
                        parsed.argv.push(value);
                    }
                    else {
                        matchedIndices.add(flagIdx);
                    }
                }
            }
        };
        fixFlag('header');
        fixFlag('header-param');
        return parsed;
    }
    parseHeaderFlags(headerFlagValues, headerParamFlagValues) {
        const headers = [];
        if (headerFlagValues) {
            headerFlagValues.forEach(value => {
                const headerOrError = (0, header_1.parseHeader)(value);
                if (headerOrError && 'error' in headerOrError) {
                    throw new errors_1.CLIError(headerOrError.error);
                }
                // A `null` from parseCurlHeaderString() means a header should NOT be
                // sent. This is not supported by zenserv / the introspection service
                // so the CLI simply omits such headers
                if (headerOrError) {
                    headers.push(headerOrError); // header
                }
            });
        }
        const headersOrError = (0, header_params_parser_1.makeHeaders)(headers, headerParamFlagValues);
        if ('error' in headersOrError) {
            throw new errors_1.CLIError(headersOrError.error);
        }
        return headersOrError;
    }
    getSqlOptionsFromFlags(flags) {
        const options = {
            host: flags['db-host'],
            user: flags['db-user'],
            password: flags['db-password'],
            database: flags['db-database'],
            linkTypes: flags['db-link-types'],
            schema: flags['db-schema'],
            include: flags['db-include'],
        };
        if ((0, utils_1.getFeatureFlag)(constants_1.USE_GENERATOR_ENGINES)) {
            // Explicitly delete all `undefined` properties to keep the
            // `generator-engines` cloud function happy
            Object.keys(options).forEach(key => {
                const k = key;
                if (options[k] === undefined) {
                    delete options[k];
                }
            });
        }
        return options;
    }
}
exports.default = Import;
Import.description = 'import a schema for an external data source or an API endpoint to your GraphQL API';
Import.commonIntrospectionFlags = {
    prefix: command_1.flags.string({
        description: '[curl, graphql] prefix to add every type in the generated schema.',
    }),
    header: command_1.flags.string({
        char: 'H',
        description: `[curl, graphql] specifies a request header to pass` +
            `\n` +
            `\nExample:` +
            `\nstepzen import curl https://example.com/api/customers \\` +
            `\n\t-H ${chalk.bold('"Authorization: apikey SecretAPIKeyValue"')}`,
        multiple: true,
    }),
    'header-param': command_1.flags.string({
        description: `[curl, graphql] specifies a parameter in a header value.` +
            ` Can be formed by taking a ${chalk.bold('-H, --header')} flag and replacing the` +
            ` variable part of the header value with a ${chalk.bold('$paramName')} placeholder. Repeat this flag once for each header with a parameter.` +
            `\n` +
            `\nExample:` +
            `\nstepzen import curl https://example.com/api/customers \\` +
            `\n\t-H "Authorization: apikey SecretAPIKeyValue" \\` +
            `\n\t--header-param 'Authorization: apikey ${chalk.bold('$apikey')}'`,
        multiple: true,
    }),
};
Import.curlFlags = {
    'query-name': command_1.flags.string({
        description: '[curl] property name to add to the Query type as a way to' +
            ' access the imported cURL endpoint.',
    }),
    'query-type': command_1.flags.string({
        description: '[curl] name for the type returned by the cURL endpoint in the ' +
            `generated schema. The name specified by ${chalk.bold('--query-type')} is not prefixed by ${chalk.bold('--prefix')} if both flags are present.`,
    }),
    'path-params': command_1.flags.string({
        description: `[curl] specifies path parameters in the URL path.` +
            ` Can be formed by taking the original path and replacing the` +
            ` variable segments with ${chalk.bold('$paramName')} placeholders.` +
            `\n` +
            `\nExample:` +
            `\nstepzen import curl https://example.com/users/jane/posts/12` +
            ` --path-params` +
            ` '/users/${chalk.bold('$userId')}/posts/${chalk.bold('$postId')}'`,
    }),
};
Import.sqlFlags = {
    'db-host': command_1.flags.string({
        description: '[mysql, postgresql] database host',
    }),
    'db-user': command_1.flags.string({
        description: '[mysql, postgresql] database user name',
    }),
    'db-password': command_1.flags.string({
        description: '[mysql, postgresql] database password',
    }),
    'db-database': command_1.flags.string({
        description: '[mysql, postgresql] name of database to import',
    }),
    'db-link-types': command_1.flags.boolean({
        description: `[mysql, postgresql] Automatically link types based on` +
            ` foreign key relationships using @materializer` +
            ` ${chalk.dim('(https://stepzen.com/docs/features/linking-types)')}`,
    }),
    'db-include': command_1.flags.enum({
        options: ['tables-only', 'views-only', 'tables-and-views'],
        description: `[mysql, postgresql] Should the generated GraphQL schema be based` +
            ` only on database views, only on tables or on both.`,
        hidden: (0, utils_1.getFeatureFlag)(constants_1.USE_GENERATOR_ENGINES),
    }),
};
Import.postgresqlFlags = {
    'db-schema': command_1.flags.string({
        description: '[postgresql] database schema',
    }),
};
Import.flagsForSchemas = [
    { flags: Import.commonIntrospectionFlags, schemas: ['curl', 'graphql'] },
    { flags: Import.curlFlags, schemas: ['curl'] },
    { flags: Import.sqlFlags, schemas: ['mysql', 'postgresql'] },
    { flags: Import.postgresqlFlags, schemas: ['postgresql'] },
];
Import.flags = Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, zen_command_1.default.flags), { dir: command_1.flags.string({ description: 'working directory' }), help: command_1.flags.help({ char: 'h' }), silent: command_1.flags.boolean({ hidden: true }), name: command_1.flags.string({
        description: 'Subfolder inside the workspace folder to save the imported' +
            ' schema files to. Defaults to the name of the imported schema.',
    }), overwrite: command_1.flags.boolean({
        description: 'Overwrite any existing schema with the same name. Cannot be used' +
            ' without also providing a --name flag.',
        dependsOn: ['name'],
        hidden: true,
    }) }), Import.commonIntrospectionFlags), Import.curlFlags), Import.sqlFlags), Import.postgresqlFlags);
Import.args = [
    {
        name: 'schema',
        required: true,
    },
];
// allow any number of arguments to support `import curl [url] [curl flags and options]`
Import.strict = false;
//# sourceMappingURL=import.js.map