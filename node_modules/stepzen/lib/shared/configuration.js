"use strict";
// Copyright (c) 2020,2021,2022, StepZen, Inc.
Object.defineProperty(exports, "__esModule", { value: true });
exports.removeCredentialsFromConfigFile = exports.writeCredentialsToConfigFile = exports.writeConfiguration = exports.readConfiguration = exports.importConfiguration = exports.ensureValidConfiguration = exports.getDBIntrospectionUrl = exports.getIntrospectionUrl = exports.appendPathnameIfEmpty = exports.getZenCtlUrl = exports.getZenCtlUrlTemplate = void 0;
// This file contains methods for managing configuration
const errors_1 = require("@oclif/errors");
const debug = require("debug");
const fs = require("fs");
const uuid_1 = require("uuid");
const path = require("path");
const yaml = require("yaml");
const stepzen_sdk_1 = require("./stepzen-sdk");
const constants_1 = require("./constants");
const configFilePath = path.join(constants_1.STEPZEN_CONFIG_DIRECTORY, constants_1.STEPZEN_CONFIG_FILE);
/**
 * Gets the zenctl service URL template potentially containing an `{account}` token to
 * be replaced. Match order: environment variable `STEPZEN_SERVER_URL`,
 * passed configuration object, default.
 *
 * @param {*} config configuration object
 * @returns {*} configured or default zenctl server URL
 */
const getZenCtlUrlTemplate = (config) => {
    var _a;
    return (process.env.STEPZEN_SERVER_URL ||
        ((_a = config.serviceInstance) === null || _a === void 0 ? void 0 : _a.zenctl) ||
        constants_1.DEFAULT_STEPZEN_SERVER_URL);
};
exports.getZenCtlUrlTemplate = getZenCtlUrlTemplate;
/**
 * Gets the zenctl service URL (ready to use). Match order: environment variable
 * `STEPZEN_SERVER_URL`, passed configuration object, hardcoded default.
 *
 * @param {*} config configuration object
 * @returns {*} configured or default zen server URL
 */
const getZenCtlUrl = (config) => {
    const urlTemplate = (0, exports.getZenCtlUrlTemplate)(config);
    return urlTemplate.replace('{account}', config.account);
};
exports.getZenCtlUrl = getZenCtlUrl;
/**
 * Adds the path component to the URL if the URL is missing one.
 *
 * @param {*} url the URL
 * @param {*} path path component
 * @returns {*} the updated URL
 */
const appendPathnameIfEmpty = (url, path) => {
    const parsedUrl = new URL(url);
    if (parsedUrl.pathname === '/') {
        parsedUrl.pathname = path;
        return parsedUrl.toString();
    }
    return url;
};
exports.appendPathnameIfEmpty = appendPathnameIfEmpty;
/**
 * Gets the introspection service URL. Match order: environment variable
 * `STEPZEN_JSON2SDL_SERVER_URL`, passed configuration object, hardcoded
 * default.
 *
 * @param {*} config configuration object
 * @returns {*} configured or default zen server URL
 */
const getIntrospectionUrl = (config) => {
    var _a;
    const url = process.env.STEPZEN_JSON2SDL_SERVER_URL ||
        ((_a = config.serviceInstance) === null || _a === void 0 ? void 0 : _a.introspection) ||
        constants_1.DEFAULT_STEPZEN_JSON2SDL_SERVER_URL;
    return (0, exports.appendPathnameIfEmpty)(url, '/api/graphql');
};
exports.getIntrospectionUrl = getIntrospectionUrl;
/**
 * Gets the database introspection service URL. Match order: environment
 * variable `STEPZEN_DBINTROSPECTION_SERVER_URL`, passed configuration
 * object, hardcoded default.
 *
 * @param {*} config configuration object
 * @returns {*} configured or default zen server URL
 */
const getDBIntrospectionUrl = (config) => {
    var _a;
    const url = process.env.STEPZEN_DBINTROSPECTION_SERVER_URL ||
        ((_a = config.serviceInstance) === null || _a === void 0 ? void 0 : _a.dbintrospection) ||
        constants_1.DEFAULT_STEPZEN_DBINTROSPECTION_SERVER_URL;
    return (0, exports.appendPathnameIfEmpty)(url, '/graphql');
};
exports.getDBIntrospectionUrl = getDBIntrospectionUrl;
/**
 * Ensure that the `stepzen-config.yaml` file exists and has valid content.
 * Cover 3 cases:
 *  - file does not exist (this is the first time the CLI is run)
 *      -> initialize the config file and add a UUID into it
 *  - file exists but does not include a UUID (it was created by an earlier
 *    version of the CLI)
 *       -> add a UUID into the existing config file
 *  - file exists, has stepzen credentials, but does not include an API key
 *    (it was created by an earlier version of the CLI)
 *       -> either fetch the API key from StepZen or remove logged in credentials
 *
 * @param {*} maybeConfiguration raw contents of the configuration file
 */
const ensureValidConfiguration = async (maybeConfiguration) => {
    let modified = false;
    const configuration = Object.assign({}, maybeConfiguration);
    // ensure configuration exists
    if (!maybeConfiguration) {
        modified = true;
    }
    // ensure configuration has a UUID
    if (!configuration.uuid) {
        configuration.uuid = (0, uuid_1.v4)();
        debug('stepzen:configuration')(`Generated a new machine UUID: ${configuration.uuid}`);
        modified = true;
    }
    // ensure a logged-in configuration includes an API key
    if (configuration.account && !configuration.apikey) {
        try {
            debug('stepzen:configuration')(`Fetching an API key for account ${configuration.account}`);
            const credentials = await stepzen_sdk_1.default.login((0, exports.getZenCtlUrlTemplate)(configuration), configuration.adminkey, configuration.account);
            configuration.apikey = credentials.apikey;
        }
        catch (error) {
            if (error instanceof Error &&
                error.message.includes('Your credentials are invalid')) {
                debug('stepzen:configuration')(`Removing the stored account credentials because logging in failed. ${error}`);
                delete configuration.account;
                delete configuration.adminkey;
                delete configuration.apikey;
            }
            else {
                // ignore other errors
            }
        }
        modified = true;
    }
    return {
        configuration: configuration,
        modified,
    };
};
exports.ensureValidConfiguration = ensureValidConfiguration;
const importConfiguration = async (filepath) => {
    if (!fs.existsSync(filepath)) {
        throw new errors_1.CLIError('Configuration file does not exist');
    }
    const content = fs.readFileSync(filepath, 'utf8');
    try {
        return yaml.parse(content);
    }
    catch (_a) {
        throw new errors_1.CLIError('Configuration file is not valid yaml');
    }
};
exports.importConfiguration = importConfiguration;
const readConfiguration = async () => {
    let maybeConfiguration = null;
    // If the configuration comes from an env var, use it
    if (process.env.STEPZEN_CONFIG_CONTENT) {
        try {
            maybeConfiguration = yaml.parse(process.env.STEPZEN_CONFIG_CONTENT);
        }
        catch (error) {
            debug('stepzen:configuration')(`Could not parse the STEPZEN_CONFIG_CONTENT env var as YAML: ${error}`);
        }
    }
    else {
        try {
            maybeConfiguration = await (0, exports.importConfiguration)(configFilePath);
        }
        catch (error) {
            debug('stepzen:configuration')(`Could not read the config file at ${configFilePath}: ${error}`);
        }
    }
    const { configuration } = await (0, exports.ensureValidConfiguration)(maybeConfiguration);
    debug('stepzen:configuration')(configuration);
    return configuration;
};
exports.readConfiguration = readConfiguration;
const writeConfiguration = async (configuration) => {
    // Generate YAML from the configuration
    const content = yaml.stringify(configuration);
    // Check that the configuration directory exists. If not, create it.
    if (!fs.existsSync(constants_1.STEPZEN_CONFIG_DIRECTORY)) {
        fs.mkdirSync(constants_1.STEPZEN_CONFIG_DIRECTORY);
    }
    // Write the configuration file. Overwrites if it already exists.
    fs.writeFileSync(configFilePath, content, { mode: '600' });
    return (0, exports.readConfiguration)();
};
exports.writeConfiguration = writeConfiguration;
const writeCredentialsToConfigFile = async (credentials) => {
    const oldConfig = await (0, exports.readConfiguration)();
    const newConfig = Object.assign(Object.assign({}, oldConfig), credentials);
    const writtenConfig = await (0, exports.writeConfiguration)(newConfig);
    return Object.assign(Object.assign({}, newConfig), writtenConfig);
};
exports.writeCredentialsToConfigFile = writeCredentialsToConfigFile;
const removeCredentialsFromConfigFile = async () => {
    const configuration = await (0, exports.readConfiguration)();
    delete configuration.account;
    delete configuration.apikey;
    delete configuration.adminkey;
    await (0, exports.writeConfiguration)(configuration);
    return configuration;
};
exports.removeCredentialsFromConfigFile = removeCredentialsFromConfigFile;
//# sourceMappingURL=configuration.js.map