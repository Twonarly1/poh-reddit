"use strict";
// Copyright (c) 2020,2021,2022, StepZen, Inc.
Object.defineProperty(exports, "__esModule", { value: true });
exports.formatEndpointInfo = exports.getFeatureFlag = exports.maskStepZenKey = exports.validateEndpoint = exports.getStepZenExtensions = exports.workspaceRelative = exports.homeRelative = exports.getDirectory = void 0;
const errors_1 = require("@oclif/errors");
const chalk = require("chalk");
const debug = require("debug");
const node_fetch_1 = require("node-fetch");
const fs = require("fs");
const os = require("os");
const path = require("path");
const prettier = require("prettier");
const constants_1 = require("./constants");
const getDirectory = (d = process.cwd()) => {
    let directory = d;
    // If it starts with `~`, expand this
    if (directory.startsWith('~')) {
        directory = directory.replace('~', os.homedir());
    }
    // If it does not now start with `/`, then get the absolute path.
    // Also, remove any `..` and `.` segments.
    directory = path.resolve(directory);
    // If the path does not exist, throw an error
    if (!fs.existsSync(directory)) {
        throw new errors_1.CLIError(`Cannot find ${directory}`);
    }
    return directory;
};
exports.getDirectory = getDirectory;
/**
 * Replace the path prefix with `~` if it is inside the user's home directory.
 *
 * @param {*} absPath an absolute file or directory path
 * @returns {*} the same path that possibly looks more friendly to users
 */
const homeRelative = (absPath) => {
    let pretty = absPath;
    if (absPath.startsWith(os.homedir())) {
        pretty = '~' + absPath.substring(os.homedir().length);
    }
    return pretty;
};
exports.homeRelative = homeRelative;
/**
 * Replace the path prefix with `~` if it is inside the user's home directory.
 *
 * @param {*} absPath an absolute file or directory path
 * @param {*} workspace an absolute file or the workspace root
 * @returns {*} the same path that possibly looks more friendly to users
 */
const workspaceRelative = (absPath, workspace) => {
    let pretty = absPath;
    if (absPath.startsWith(workspace)) {
        pretty = '.' + absPath.substring(workspace.length);
    }
    return pretty;
};
exports.workspaceRelative = workspaceRelative;
const getStepZenExtensions = async () => {
    const domain = constants_1.STEPZEN_DOMAIN.replace('.io', '.net');
    const url = `https://www.${domain}/directives.graphql`;
    const response = await (0, node_fetch_1.default)(url);
    const schema = await response.text();
    const formatted = prettier.format(schema, { parser: 'graphql' });
    debug('stepzen:extensions')(`Fetching StepZen extensions from ${url}`);
    debug('stepzen:extensions')(`Extensions: ${formatted}`);
    return formatted;
};
exports.getStepZenExtensions = getStepZenExtensions;
const validateEndpoint = (endpoint) => {
    const error = chalk `Expected the endpoint name to be of the format {bold folder/name},` +
        chalk ` matching the pattern {bold ^[\\w-]+$}` +
        chalk ` but got {bold ${endpoint}}.`;
    if (endpoint.includes('/') === false)
        return error;
    const parts = endpoint.split('/');
    if (parts.some(part => part.trim() === ''))
        return error;
    if (parts.some(part => part.match(/^[\d_-]+.*$/)))
        return error;
    if (parts.some(part => !part.match(/^[\w-]+$/)))
        return error;
    return true;
};
exports.validateEndpoint = validateEndpoint;
const maskStepZenKey = (key) => {
    const parts = key.split('::');
    const thirdPart = parts[2];
    const firstTwoChars = thirdPart.substring(0, 2);
    const lastTwoChars = thirdPart.slice(-2);
    const stars = '*'.repeat(thirdPart.length - 4);
    const maskedThirdPart = `${firstTwoChars}${stars}${lastTwoChars}`;
    const masked = `${parts[0]}::${parts[1]}::${maskedThirdPart}  `;
    return masked;
};
exports.maskStepZenKey = maskStepZenKey;
const getFeatureFlag = (flag) => {
    const value = process.env[flag];
    if (value === undefined) {
        return false;
    }
    return value.toLowerCase() !== 'false';
};
exports.getFeatureFlag = getFeatureFlag;
const formatEndpointInfo = ({ account, endpoint, proxyport, }) => {
    const domain = constants_1.STEPZEN_DOMAIN.replace('.io', '.net');
    const url = `https://${account}.${domain}/${endpoint}/__graphql`;
    const lines = [];
    lines.push('');
    if (process.platform === 'win32') {
        lines.push(chalk.grey(`In PowerShell you can test your hosted API with Invoke-WebRequest:`));
        lines.push('');
        lines.push(`Invoke-WebRequest \``);
        lines.push(`   -Uri ${url} \``);
        lines.push(`   -Method "POST" \``);
        lines.push(`   -Headers @{`);
        lines.push(`     "Content-Type" = "application/json"`);
        if (!account.startsWith('public')) {
            lines.push(`     "Authorization" = "APIKey $(stepzen whoami --apikey)"`);
        }
        lines.push(`   } \``);
        lines.push(`   -Body (@{`);
        lines.push(`     "query" = 'query SampleQuery { __schema { queryType { name description } } }'`);
        lines.push(`   } | ConvertTo-Json)`);
    }
    else {
        lines.push(chalk.grey(`You can test your hosted API with cURL:`));
        lines.push('');
        lines.push(`curl ${url} \\`);
        if (!account.startsWith('public')) {
            lines.push(`   --header "Authorization: Apikey $(stepzen whoami --apikey)" \\`);
        }
        lines.push(`   --header "Content-Type: application/json" \\`);
        lines.push(`   --data-raw '{`);
        lines.push(`     "query": "query SampleQuery { __schema { queryType { name description } } }"`);
        lines.push(`   }'`);
    }
    if (proxyport) {
        lines.push('');
        lines.push(chalk.grey(`or explore it with GraphiQL at http://localhost:${proxyport}/${endpoint}`));
    }
    lines.push('');
    lines.push(chalk.grey(`Your API url is ${chalk.green(url)}`));
    return lines.join('\n');
};
exports.formatEndpointInfo = formatEndpointInfo;
//# sourceMappingURL=utils.js.map