"use strict";
// Copyright (c) 2020,2021,2022, StepZen, Inc.
Object.defineProperty(exports, "__esModule", { value: true });
exports.initWorkspace = exports.getWorkspace = exports.guessSchemaRoot = exports.generateWorkspaceName = exports.validateWorkspaceName = void 0;
const errors_1 = require("@oclif/errors");
const fs = require("fs");
const glob = require("glob");
const inquirer = require("inquirer");
const os = require("os");
const path = require("path");
const moniker_1 = require("../shared/moniker");
const utils_1 = require("./utils");
const validateWorkspaceName = (directory, name) => {
    return !fs.existsSync(path.join(directory, name));
};
exports.validateWorkspaceName = validateWorkspaceName;
const generateWorkspaceName = (directory) => {
    let name = 'hello-stepzen';
    while (!(0, exports.validateWorkspaceName)(directory, name)) {
        name = `hello-${(0, moniker_1.getRandomDescriptor)()}-stepzen`;
    }
    return name;
};
exports.generateWorkspaceName = generateWorkspaceName;
const guessSchemaRoot = (directory) => {
    const existing = [
        ...glob.sync('*/**/config.yaml', {
            cwd: directory,
            ignore: '**/node_modules/**',
        }),
        ...glob.sync('*/**/index.graphql', {
            cwd: directory,
            ignore: '**/node_modules/**',
        }),
    ];
    return existing.length > 0 ? path.dirname(existing[0]) : '';
};
exports.guessSchemaRoot = guessSchemaRoot;
const getWorkspace = (directory) => {
    let workspaceRoot;
    const parts = path
        // Remove trailing slashes and any `..` and `.` segments
        .resolve(directory)
        // split into segments
        .split(path.sep);
    // Loop through this and all parent directories up to $HOME to find the root
    for (; parts.length > 0; parts.pop()) {
        const d = parts.join(path.sep);
        const f = path.join(d, 'stepzen.config.json');
        if (fs.existsSync(f)) {
            workspaceRoot = d;
            break;
        }
        if (d === os.homedir()) {
            break;
        }
    }
    if (!workspaceRoot) {
        return null;
    }
    const filepath = path.join(workspaceRoot, 'stepzen.config.json');
    const file = fs.readFileSync(filepath, 'utf8');
    let config;
    try {
        config = JSON.parse(file);
    }
    catch (_a) {
        throw new errors_1.CLIError(`Cannot parse configuration from ${filepath}`);
    }
    // Validate the workspace
    const error = (0, utils_1.validateEndpoint)(config.endpoint);
    if (typeof error === 'string') {
        throw new errors_1.CLIError(error);
    }
    // Add the 'schema' property, which is the directory + the 'root'
    const schema = path.join(workspaceRoot, config.root || '');
    if (!fs.existsSync(schema)) {
        throw new errors_1.CLIError(`Cannot find workspace schema folder ${schema}`);
    }
    return {
        directory: workspaceRoot,
        endpoint: config.endpoint,
        schema: schema,
    };
};
exports.getWorkspace = getWorkspace;
const initWorkspace = async (args) => {
    // Get the correct directory
    let directory = (0, utils_1.getDirectory)(args.directory);
    // Make sure it is not already a workspace
    if ((0, exports.getWorkspace)(directory)) {
        throw new errors_1.CLIError(`This directory is already a StepZen workspace: ${directory}.` +
            ' Please select a different directory.');
    }
    const isHomeDir = directory === os.homedir();
    // Prevent init from running in the home directory if the directory was
    // explicitly provided as an aargument to `stepzen init`.
    // StepZen CLI sometimes would enumerate all files in the workspace folder
    // doing so in the home directory is likely to fail.
    if (args.directory && isHomeDir) {
        throw new errors_1.CLIError('Using the home directory as a StepZen workspace is not supported.' +
            ' Please select a different directory.');
    }
    // Make a suggestion for the workspace name (if running in the HOME
    // directory)
    const name = isHomeDir
        ? (0, exports.generateWorkspaceName)(directory)
        : path.basename(directory);
    // See if we think there's a StepZen schema already
    const root = isHomeDir ? '' : (0, exports.guessSchemaRoot)(directory);
    // If you've passed an endpoint, validate it, and throw an error
    // straight away if needed
    if (args.endpoint) {
        const error = (0, utils_1.validateEndpoint)(args.endpoint);
        if (typeof error === 'string') {
            throw new errors_1.CLIError(error);
        }
    }
    // Make a suggestion for the endpoint
    const endpoint = args.endpoint || `api/${(0, moniker_1.default)()}`;
    // What questions will we ask?
    const questions = [
        {
            default: name,
            message: 'What would you like to call your workspace?',
            name: 'name',
            validate: (name) => (0, exports.validateWorkspaceName)(directory, name),
            when: isHomeDir && !args.yes,
        },
        {
            default: endpoint,
            message: 'What would you like your endpoint to be called?',
            name: 'endpoint',
            validate: utils_1.validateEndpoint,
            when: !args.endpoint && !args.yes,
        },
        {
            message: `We have detected a schema in this directory. Set the schema root to "${root}"?`,
            name: 'use-root',
            type: 'confirm',
            when: Boolean(root) && !args.yes,
        },
    ];
    // Get the answers
    const answers = Object.assign({ name,
        endpoint, 'use-root': true }, (await inquirer.prompt(questions)));
    // Append the suggested workspace name to the directory (if running
    // in the HOME directory)
    if (isHomeDir) {
        // eslint-disable-next-line require-atomic-updates
        directory = path.join(directory, answers.name);
        fs.mkdirSync(directory);
    }
    // Create the workspace
    const workspace = { endpoint: answers.endpoint };
    if (root && answers['use-root'])
        workspace.root = root;
    // Write the file
    const file = path.join(directory, 'stepzen.config.json');
    fs.writeFileSync(file, JSON.stringify(workspace, null, '  '));
    // Fetch the newly created workspace
    const created = (0, exports.getWorkspace)(directory);
    return created;
};
exports.initWorkspace = initWorkspace;
//# sourceMappingURL=workspace.js.map