"use strict";
// Copyright (c) 2020,2021,2022, StepZen, Inc.
Object.defineProperty(exports, "__esModule", { value: true });
exports.makeHeaders = exports.parseHeaderParam = void 0;
const chalk = require("chalk");
const debug = require("debug");
const header_1 = require("./header");
const headerParamRegex = /^(?<prefix>([^$]|\$\$)*)(?<param>\$[_A-Za-z]\w*);?(?<suffix>.*)$/;
const parseHeaderParam = (headers, headerParam) => {
    const headerOrError = (0, header_1.parseHeader)(headerParam);
    if (!headerOrError || 'error' in headerOrError) {
        if (headerOrError) {
            debug('stepzen:curl2sdl')(`Failed to parse a header param ${headerParam}.` +
                ` Error: ${headerOrError.error}`);
        }
        return {
            error: `Could not find a header name in` +
                ` ${chalk.bold(`--header-param '${headerParam}'`)}.`,
        };
    }
    const { name, value } = headerOrError;
    const paramValueMatches = value.match(headerParamRegex);
    if (!paramValueMatches || !paramValueMatches.groups) {
        return {
            error: `Could not find a $-prefixed parameter name in` +
                ` ${chalk.bold(`--header-param '${headerParam}'`)}.` +
                ` Did you use single quotes to prevent shell variable expansion?`,
        };
    }
    const prefix = paramValueMatches.groups.prefix.replace(/\$\$/g, '$');
    const paramName = paramValueMatches.groups.param.substring(1);
    const suffix = paramValueMatches.groups.suffix.replace(/\$\$/g, '$');
    if (suffix.match(headerParamRegex)) {
        return {
            error: `StepZen CLI currently supports at max 1 parameter per header` +
                ` ${chalk.bold(`--header-param '${headerParam}'`)} has several.`,
        };
    }
    const candidates = headers.filter(h => h.name.toLowerCase() === name.toLowerCase());
    if (candidates.length === 0) {
        return {
            error: `Could not find a matching '-H, --header' curl flag for` +
                ` ${chalk.bold(`--header-param '${headerParam}'`)}.` +
                ` No header matches the name ${name}.`,
        };
    }
    const matches = candidates.filter(({ value }) => value.startsWith(prefix) &&
        value.substring(prefix.length).endsWith(suffix));
    if (matches.length === 0) {
        return {
            error: `Could not find a matching '-H, --header' curl flag for` +
                ` ${chalk.bold(`--header-param '${headerParam}'`)}.` +
                (candidates.length > 1
                    ? ` None of the ${name} headers matches the '${value}' pattern.`
                    : ` The ${name} header does not match the '${value}' pattern.`),
        };
    }
    if (matches.length > 1) {
        debug('stepzen:curl2sdl')(`Ambiguous --header-param '${headerParam}'. Matched headers:` +
            `\n${matches
                .map(header => `\t-H '${header.name}: ${header.value}'`)
                .join('\n')}` +
            `\nUsing the first match.`);
    }
    const asConstantHeaderValuePart = (value) => ({
        kind: 'Constant',
        value,
    });
    const asVariableHeaderValuePart = (value, name) => ({
        kind: 'Variable',
        value,
        name,
    });
    return {
        header: {
            name: matches[0].name,
            parts: [
                ...(prefix
                    ? [asConstantHeaderValuePart(prefix)]
                    : [
                    /* spreading an empty array is a no-op */
                    ]),
                asVariableHeaderValuePart(matches[0].value.substring(prefix.length, matches[0].value.length - suffix.length), paramName),
                ...(suffix
                    ? [asConstantHeaderValuePart(suffix)]
                    : [
                    /* spreading an empty array is a no-op */
                    ]),
            ],
        },
        // assume each --header is referenced by at most one --header-param
        remainingHeaders: headers.filter(h => h !== matches[0]),
    };
};
exports.parseHeaderParam = parseHeaderParam;
const makeHeaders = (curlHeaders, headerParams = []) => {
    const headers = [];
    let remainingCurlHeaders = curlHeaders;
    for (const headerParam of headerParams) {
        const resultOrError = (0, exports.parseHeaderParam)(remainingCurlHeaders, headerParam);
        if ('error' in resultOrError) {
            return resultOrError;
        }
        headers.push(resultOrError.header);
        remainingCurlHeaders = resultOrError.remainingHeaders;
    }
    headers.push(...remainingCurlHeaders);
    return headers;
};
exports.makeHeaders = makeHeaders;
//# sourceMappingURL=header-params-parser.js.map