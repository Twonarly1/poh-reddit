"use strict";
// Copyright (c) 2020,2021,2022, StepZen, Inc.
Object.defineProperty(exports, "__esModule", { value: true });
const errors_1 = require("@oclif/errors");
const core_1 = require("@oclif/core");
const fs = require("fs-extra");
const lodash_1 = require("lodash");
const path = require("path");
const transpiler = require("@stepzen/transpiler");
const helpers_1 = require("./helpers");
exports.default = async ({ schema, name, onConflict, source, preAnswered = {}, }) => {
    var _a, _b, _c;
    // Store the generator
    let generator;
    // Initial answers from flags, keyed as <schema>_config
    let answers = {
        [`${schema}_config`]: preAnswered,
    };
    // Start downloading
    core_1.CliUx.ux.action.start('Downloading from StepZen...');
    // Get the generator configuration
    const configure = await (0, helpers_1.getConfiguration)(schema, answers);
    if (((_a = configure === null || configure === void 0 ? void 0 : configure.questions) === null || _a === void 0 ? void 0 : _a.length) ||
        ((configure === null || configure === void 0 ? void 0 : configure.status) && configure.status >= 0)) {
        generator = {
            questions: configure.questions,
            type: 'generator',
            answers: undefined,
        };
    }
    if ((_b = configure === null || configure === void 0 ? void 0 : configure.errors) === null || _b === void 0 ? void 0 : _b.error) {
        throw new errors_1.CLIError(configure.errors.error);
    }
    // For housekeeping
    const tempFiles = [];
    const cleanUp = async () => {
        // Silently ignore temporary files that could not be deleted (error message would be
        // useless and allows simpler mocking by not having to actually create files).
        await Promise.all(tempFiles.map(file => fs
            .access(file, fs.constants.W_OK)
            .then(() => fs.remove(file))
            .catch(() => undefined)));
    };
    // Get the API templates repository
    let templates;
    if (generator === undefined) {
        templates = await (0, helpers_1.getTemplates)();
        if (fs.existsSync(`${templates}/${schema}`)) {
            const file = path.join(templates, schema, 'stepzen.config.json');
            const config = fs.readFileSync(file, 'utf8');
            const json = JSON.parse(config);
            generator = {
                questions: ((_c = json === null || json === void 0 ? void 0 : json.config) === null || _c === void 0 ? void 0 : _c.questions) || [],
                type: 'template',
                answers: undefined,
            };
            tempFiles.push(templates);
        }
    }
    // Finished downloading
    core_1.CliUx.ux.action.stop();
    console.log();
    let result;
    if (generator === undefined) {
        // If you've tried to import non-existent templates, complain and exit
        cleanUp();
        throw new errors_1.CLIError(`Cannot find the schema ${schema}`);
    }
    else if (generator.type === 'generator') {
        result = await (0, helpers_1.askGeneratorQuestions)(schema, generator, answers);
    }
    else if (generator.type === 'template') {
        result = await (0, helpers_1.askTemplateQuestions)(schema, generator, answers);
    }
    generator.answers = result;
    answers = (0, lodash_1.merge)(answers, result);
    // We now have all the answers! Generate schemas
    console.log();
    core_1.CliUx.ux.action.start('Generating schemas...');
    let files;
    if (generator.type === 'generator') {
        files = await (0, helpers_1.createGeneratorFiles)(schema, generator);
        tempFiles.push(files);
    }
    else {
        // if (generator.type === 'template')
        files = path.join(templates, schema);
    }
    const output = await transpiler.merge(source, {
        name: name || schema,
        source: files,
    }, {
        answers,
        silent: true,
        output: null,
        onConflict,
    });
    core_1.CliUx.ux.action.stop();
    // Housekeeping
    cleanUp();
    return output;
};
//# sourceMappingURL=index.js.map