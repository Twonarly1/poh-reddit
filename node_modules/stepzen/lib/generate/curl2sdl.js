"use strict";
// Copyright (c) 2020,2021,2022, StepZen, Inc.
Object.defineProperty(exports, "__esModule", { value: true });
exports.curl2sdl = exports.askCurlQuestions = exports.makeDuplicateParamsMessage = exports.compileParameterList = void 0;
const chalk = require("chalk");
const inquirer = require("inquirer");
const lodash_1 = require("lodash");
const string_argv_1 = require("string-argv");
const curl_parser_1 = require("../shared/curl-parser");
const path_params_parser_1 = require("../shared/path-params-parser");
const helpers_1 = require("./helpers");
const configuration_1 = require("../shared/configuration");
/**
 * Collect together all query parameters from HTTP headers and from the
 * pathname, and return them as a uniform list.
 *
 * @param {*} headers list of curl headers, possibly with parameters
 * @param {*} pathParams list of path parameters
 * @param {*} pathname full pathname of the REST endpoint
 * @returns {*} combined list of query parameters in a uniform format
 */
const compileParameterList = (headers, pathParams, pathname) => {
    // Drop empty segments, including empty string before the leading slash
    const pathSegments = pathname.split('/').filter(Boolean);
    // For each header, make a list of the parameters it contains.
    // `flatMap()` concatenates each header's param lists into a single list.
    return (0, lodash_1.flatMap)(headers, header => {
        // skip headers that don't contain parameters
        if (!('parts' in header)) {
            return [];
        }
        // Reconstruct the full header string (for the context).
        const fullHeader = `${header.name}: ${header.parts
            .map(part => part.value)
            .join('')}`;
        // Filter out the 'Variable' parts of the header value, and convert them
        // to the `CurlyQueryParameter` structure.
        return header.parts
            .map(part => part.kind === 'Variable'
            ? {
                name: part.name,
                value: part.value,
                context: `'${header.name}' header ${chalk.dim(`(${fullHeader})`)}`,
            }
            : null)
            .filter(Boolean); // remove nulls
    }).concat(
    // Append the path parameters to the list, converting them to
    // the `CurlyQueryParameter` structure as well.
    pathParams.map(param => ({
        name: param.name,
        value: pathSegments[param.index],
        context: `pathname ${chalk.dim(`(${pathname})`)}`,
    })));
};
exports.compileParameterList = compileParameterList;
/**
 * Check the header and path parameters for duplicates, and construct a
 * user-friendly error message describing identified problems (if any).
 * If no problems are found, return `null`.
 *
 * @param {*} headers list of curl headers, possibly with parameters
 * @param {*} pathParams list of path parameters
 * @param {*} url full URL of the REST endpoint
 * @returns {*} a message describing duplicate query parameters, or null if
 *              there are no duplicates
 */
const makeDuplicateParamsMessage = (headers, pathParams, url) => {
    // Create a uniform list of query parameters from the headers and path
    const parameters = (0, exports.compileParameterList)(headers, pathParams, new URL(url).pathname);
    const errors = Object.entries((0, lodash_1.groupBy)(parameters, 'name'))
        // Create groups for each unique parameter name,
        // and then sub-groups for each unique [name, value] tuple.
        .map(([name, group]) => ({
        name,
        values: Object.entries((0, lodash_1.groupBy)(group, 'value')),
    }))
        // ignore the [name, value] tuples that occur only once
        .filter(({ values }) => values.length > 1)
        // for the rest, create a message describing the duplicates
        .map(({ name, values }) => `The parameter ${chalk.bold(`$${name}`)} is used for ${values.length} different values:` +
        `\n${values
            .map(([value, params], i) => `\t${i + 1}: '${value}' in the ${params[0].context}`)
            .join('\n')}`);
    if (errors.length > 0) {
        return ('Could not use the same name for different parameters.\n' +
            errors.join('\n') +
            '\nPlease give a different parameter name for each variable value.');
    }
    return null;
};
exports.makeDuplicateParamsMessage = makeDuplicateParamsMessage;
const askCurlQuestions = async (defaultAnswers = {}) => {
    const questions = [
        {
            name: 'url',
            message: 'Endpoint URL or a full curl command',
        },
        {
            name: 'pathParams',
            message: 'Parameters for endpoint URL path',
        },
        {
            name: 'queryName',
            message: 'Query name to use when generating schema (leave blank to use defaults)',
        },
        {
            name: 'rootType',
            message: 'Query type name to use when generating schema (leave blank to use defaults)',
        },
        {
            name: 'typePrefix',
            message: 'Prefix to add to all generated type names (leave blank to use defaults)',
        },
    ];
    const answers = await inquirer.prompt((0, helpers_1.overrideDefaults)(questions, defaultAnswers));
    const curlArgs = (0, curl_parser_1.parseCurlArgv)((0, string_argv_1.default)(answers.url));
    if ('error' in curlArgs) {
        console.log();
        console.log(chalk.red('A problem occurred while parsing the curl command:\n', curlArgs.error), '\nPlease enter a URL or a supported curl command.');
        console.log();
        return (0, exports.askCurlQuestions)(answers);
    }
    const parsedPathParamsOrError = (0, path_params_parser_1.parsePathParamsPattern)(curlArgs.url, answers.pathParams);
    if ('error' in parsedPathParamsOrError) {
        console.log();
        console.log(chalk.red('A problem occurred while parsing path parameters pattern:\n', parsedPathParamsOrError.error));
        console.log();
        console.log(`Please enter a path parameter specification that` +
            ` can be formed by taking the original path and replacing the variable` +
            ` segments with ${chalk.bold('$paramName')} placeholders.`);
        console.log();
        console.log('Example:\n' +
            `\tendpoint URL: https://example.com/users/jane/posts/12\n ` +
            `\tpath parameters: /users/${chalk.bold('$userId')}/posts/${chalk.bold('$postId')}`);
        console.log();
        return (0, exports.askCurlQuestions)(answers);
    }
    return {
        curlArgs,
        queryName: answers.queryName,
        rootType: answers.rootType,
        typePrefix: answers.typePrefix,
        pathParams: parsedPathParamsOrError,
    };
};
exports.askCurlQuestions = askCurlQuestions;
const curl2sdl = async ({ curlArgs, name, source, queryName, rootType, typePrefix, pathParams, headers, onConflict, }, configuration) => {
    const response = await (0, helpers_1.queryIntrospectionService)((0, configuration_1.getIntrospectionUrl)(configuration), {
        operation: 'getSDLFromCurl',
        variables: {
            command: {
                type: 'String!',
                value: curlArgs.url,
            },
            queryName: {
                type: 'String',
                value: queryName || null,
            },
            rootType: {
                type: 'String',
                value: rootType || null,
            },
            typePrefix: {
                type: 'String',
                value: typePrefix || null,
            },
            headers: {
                type: '[HeaderInput!]',
                value: headers && headers.length > 0 ? headers : null,
            },
            data: {
                type: 'String',
                value: curlArgs.data || null,
            },
            method: {
                type: 'HTTPMethod!',
                value: curlArgs.method,
            },
            pathParams: {
                type: '[PathParamInput!]',
                value: pathParams.length > 0 ? pathParams : null,
            },
        },
    });
    if (response.error) {
        return { error: response.error };
    }
    return (0, helpers_1.writeSdlAndConfig)({
        name: name || 'curl',
        source,
        onConflict,
        response,
    });
};
exports.curl2sdl = curl2sdl;
//# sourceMappingURL=curl2sdl.js.map