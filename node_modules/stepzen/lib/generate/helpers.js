"use strict";
// Copyright (c) 2020,2021,2022, StepZen, Inc.
Object.defineProperty(exports, "__esModule", { value: true });
exports.overrideDefaults = exports.writeSdlAndConfig = exports.queryIntrospectionService = exports.askTemplateQuestions = exports.askGeneratorQuestions = exports.getTemplates = exports.getSchema = exports.getConfiguration = exports.createGeneratorFiles = void 0;
const errors_1 = require("@oclif/errors");
const chalk = require("chalk");
const debug = require("debug");
const node_fetch_1 = require("node-fetch");
const fs = require("fs-extra");
const inquirer = require("inquirer");
const lodash_1 = require("lodash");
const os = require("os");
const path = require("path");
const shell = require("shelljs");
const transpiler = require("@stepzen/transpiler");
const prettier = require("prettier");
const constants_1 = require("../shared/constants");
const errors_2 = require("../shared/errors");
const { version } = require('../../package.json');
const createGeneratorFiles = async (id, details) => {
    const url = `${constants_1.STEPZEN_DIRECT_GENERATOR_ENGINES_URL}/create`;
    debug('stepzen:generate')(`calling the generator engine ${id} via ${url}`);
    const engineErrorMessageWrap = (msg) => `An error has occurred when creating the schema: ${msg}. Please check your parameters and try again.`;
    try {
        const response = await (0, node_fetch_1.default)(url, {
            body: JSON.stringify({
                id,
                details: JSON.stringify(details.answers),
            }),
            headers: {
                'Content-Type': 'application/json',
                'User-Agent': `stepzen-cli/${version}`,
            },
            method: 'POST',
        });
        const responseJson = await response.json();
        if (responseJson.errors) {
            // assuming a response of type { status: Int, errors: String }
            throw new errors_1.CLIError(engineErrorMessageWrap(responseJson.errors));
        }
        else {
            // where errors is an error message if name === null.
            const files = responseJson;
            const tmp = path.join(os.tmpdir(), `stepzen-generated-schema-${Date.now()}`);
            fs.ensureDirSync(tmp);
            for (const file of files) {
                if (file.errors) {
                    throw new errors_1.CLIError(engineErrorMessageWrap(file.errors));
                }
                else {
                    const dir = path.join(tmp, file.name);
                    fs.writeFileSync(dir, file.content);
                }
            }
            return tmp;
        }
    }
    catch (error) {
        debug('stepzen:generate')(error);
        throw error instanceof errors_1.CLIError
            ? error
            : new errors_1.CLIError(errors_2.PERMANENT_STEPZEN_ERROR);
    }
};
exports.createGeneratorFiles = createGeneratorFiles;
const getConfiguration = async (id, details = {}) => {
    const url = `${constants_1.STEPZEN_DIRECT_GENERATOR_ENGINES_URL}/configure`;
    debug('stepzen:generate')(`calling the generator engine ${id} via ${url}`);
    try {
        const response = await (0, node_fetch_1.default)(url, {
            body: JSON.stringify({
                id,
                details: JSON.stringify(details),
            }),
            headers: {
                'Content-Type': 'application/json',
                'User-Agent': `stepzen-cli/${version}`,
            },
            method: 'POST',
        });
        const { answers, errors, questions, status } = await response.json();
        return {
            answers: JSON.parse(answers),
            errors: JSON.parse(errors),
            questions: JSON.parse(questions),
            status: JSON.parse(status),
        };
    }
    catch (error) {
        debug('stepzen:generate')(error);
        throw new errors_1.CLIError(errors_2.PERMANENT_STEPZEN_ERROR);
    }
};
exports.getConfiguration = getConfiguration;
const getSchema = (arg) => {
    const schema = arg.trim();
    // Now supports importing only one schema at a time:
    // https://github.com/steprz/stepzen-cli/issues/628
    if (schema.includes(',') || schema.includes(' ')) {
        throw new errors_1.CLIError("Importing multiple schemas is no longer supported; please specify only one (e.g. 'stepzen import mysql')");
    }
    // support `postgres` as an alias to `postgresql`
    // https://github.com/steprz/stepzen-cli/issues/431
    if (schema.toLowerCase() === 'postgres') {
        return 'postgresql';
    }
    return schema;
};
exports.getSchema = getSchema;
const getTemplates = async () => {
    const tmp = path.join(os.tmpdir(), `stepzen-api-templates-${Date.now()}`);
    fs.ensureDirSync(tmp);
    const repository = constants_1.STEPZEN_API_TEMPLATES_REPOSITORY;
    const command = `git clone ${repository} ${tmp}`;
    const result = shell.exec(command, { silent: true });
    if (result.code !== 0) {
        throw new errors_1.CLIError(result.stderr.trim());
    }
    return tmp;
};
exports.getTemplates = getTemplates;
const askGeneratorQuestions = async (id, settings, state) => {
    var _a, _b;
    let status = -1;
    do {
        const questions = settings.questions.map((question) => {
            return Object.assign(Object.assign({ type: 'password' }, question), { 
                // set the previous iteration's answer as the default value, except for password fields
                default: question.type && question.type !== 'password'
                    ? (0, lodash_1.get)(state, question.name)
                    : undefined });
        });
        // eslint-disable-next-line no-await-in-loop
        const answers = await inquirer.prompt(questions);
        state = (0, lodash_1.merge)(state, answers);
        // eslint-disable-next-line no-await-in-loop
        const result = await (0, exports.getConfiguration)(id, state);
        if (!result) {
            // at this point the generator ${id} should have been validated
            throw new errors_1.CLIError(errors_2.PERMANENT_STEPZEN_ERROR);
        }
        if (result.status === -1 && result.questions.length === 0) {
            console.log();
            console.log(chalk.red(`A problem occurred when running ${id} import${((_a = result.errors) === null || _a === void 0 ? void 0 : _a.error) ? `: "${(_b = result.errors) === null || _b === void 0 ? void 0 : _b.error}"` : '.'}`));
            console.log('Please try again and check command-line parameters');
            if (questions.length === 0) {
                // all questions are pre-answered, so there is no chance to save the
                // situation interactively => don't loop
                throw new errors_1.CLIError('Unable to import');
            }
        }
        else {
            settings = {
                questions: result.questions,
            };
            // eslint-disable-next-line require-atomic-updates
            state = (0, lodash_1.merge)(state, result.answers);
        }
        status = result.status;
    } while (status === -1);
    return state;
};
exports.askGeneratorQuestions = askGeneratorQuestions;
const askTemplateQuestions = async (id, settings, state) => {
    const questions = settings.questions.map((question) => (Object.assign({ type: 'password' }, question)));
    const answers = await inquirer.prompt(questions);
    return Object.assign(Object.assign({}, state), answers);
};
exports.askTemplateQuestions = askTemplateQuestions;
const queryIntrospectionService = async (serverUrl, query) => {
    let json;
    try {
        debug('stepzen:introspection')(serverUrl);
        const queryString = `query (
      ${Object.entries(query.variables).map(([id, { type }]) => `$${id}: ${type}`)} 
      ) { 
        ${query.operation}(${Object.keys(query.variables).map(id => `${id}: $${id}`)}) {
          sdl
          config
        } 
    }`;
        debug('stepzen:introspection')(queryString);
        debug('stepzen:introspection')(query.variables);
        const payload = JSON.stringify({
            query: queryString,
            variables: (0, lodash_1.mapValues)(query.variables, ({ value }) => value),
        });
        debug('stepzen:introspection')(payload);
        const response = await (0, node_fetch_1.default)(serverUrl, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: payload,
        });
        const text = await response.text();
        debug('stepzen:introspection')(text);
        json = JSON.parse(text);
    }
    catch (error) {
        debug('stepzen:introspection')(error);
        throw new errors_1.CLIError(errors_2.PERMANENT_STEPZEN_ERROR);
    }
    if (!json.data && !json.errors) {
        debug('stepzen:introspection')('expected the response from the JSON introspection service ' +
            'to contain either `data` or `errors`');
        throw new errors_1.CLIError(errors_2.PERMANENT_STEPZEN_ERROR);
    }
    if (json.errors) {
        const compileError = (error) => {
            var _a, _b, _c;
            return error.message +
                // error.extensions.Message: DB introspection API (e.g. wrong password)
                (((_a = error.extensions) === null || _a === void 0 ? void 0 : _a.Message) ? `: ${error.extensions.Message}` : '') +
                // error.extensions.details: REST instrospection API (e.g. 401 / unauthorized)
                (((_b = error.extensions) === null || _b === void 0 ? void 0 : _b.details)
                    ? `: ${JSON.stringify(error.extensions.details)}`
                    : '') +
                // error.extensions.cause: DB introspection API (e.g. --db-include=views-only and there are no views)
                (((_c = error.extensions) === null || _c === void 0 ? void 0 : _c.cause)
                    ? `: ${JSON.stringify(error.extensions.cause)}`
                    : '');
        };
        return { error: json.errors.map(compileError).join('\n') };
    }
    if (!json.data[query.operation]) {
        debug('stepzen:graphql2sdl')('expected the response from the JSON introspection service ' +
            `to contain a \`${query.operation}\` object`);
        throw new errors_1.CLIError(errors_2.PERMANENT_STEPZEN_ERROR);
    }
    const { config, sdl } = json.data[query.operation];
    if (!config && !sdl) {
        debug('stepzen:curl2sdl')('expected the response from the JSON introspection service ' +
            `to contain at least one of \`${query.operation}.config\` or ` +
            `\`${query.operation}.sdl\` properties`);
        throw new errors_1.CLIError(errors_2.PERMANENT_STEPZEN_ERROR);
    }
    return { config, sdl };
};
exports.queryIntrospectionService = queryIntrospectionService;
const writeSdlAndConfig = async ({ name, source, mergeTypes = false, onConflict, response, }) => {
    const { config, sdl } = response;
    // write out the generated config and schema files
    const tmp = path.join(os.tmpdir(), `stepzen-introspection-${Date.now()}`);
    fs.ensureDirSync(tmp);
    // fs.ensureDirSync(path.join(tmp, subfolder))
    if (config) {
        fs.writeFileSync(path.join(tmp, 'config.yaml'), prettier.format(config, { parser: 'yaml' }));
    }
    if (sdl) {
        fs.writeFileSync(path.join(tmp, 'index.graphql'), prettier.format(sdl, { parser: 'graphql' }));
    }
    const result = await transpiler.merge(source, {
        name: name,
        source: tmp,
    }, {
        answers: {},
        output: null,
        silent: true,
        mergeTypes,
        onConflict,
    });
    return { outPath: result };
};
exports.writeSdlAndConfig = writeSdlAndConfig;
const overrideDefaults = (questions, defaultAnswers) => {
    return questions.map(question => {
        const def = (0, lodash_1.get)(defaultAnswers, question.name);
        return def === undefined ? question : Object.assign(Object.assign({}, question), { default: def });
    });
};
exports.overrideDefaults = overrideDefaults;
//# sourceMappingURL=helpers.js.map