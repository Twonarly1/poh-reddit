"use strict";
// Copyright (c) 2020,2021,2022, StepZen, Inc.
Object.defineProperty(exports, "__esModule", { value: true });
exports.sql2sdl = exports.askSqlQuestions = exports.parseHost = void 0;
const chalk = require("chalk");
const inquirer = require("inquirer");
const helpers_1 = require("./helpers");
const configuration_1 = require("../shared/configuration");
const parseHost = (host) => {
    if (!host) {
        return { host: undefined, port: undefined, isValid: false };
    }
    let url;
    // Try parsing as a DNS name or an IPv4 address (possibly with a port)
    // e.g. "example.com:5432" or "[fedc:ba98:7654:3210:fedc:ba98:7654:3210]:5432"
    try {
        url = new URL(`http://${host}`);
    }
    catch (_a) {
        // Try parsing as an IPv6 address (without a port)
        // e.g. fedc:ba98:7654:3210:fedc:ba98:7654:3210
        try {
            url = new URL(`http://[${host}]`);
        }
        catch (_b) {
            // ignore
        }
    }
    if (!url) {
        return { host, port: undefined, isValid: false };
    }
    return {
        host: url.hostname,
        port: url.port || undefined,
        isValid: true,
    };
};
exports.parseHost = parseHost;
const askSqlQuestions = async (dbType, defaultAnswers = {}) => {
    let questions = [
        {
            name: 'host',
            message: 'What is your host?',
            validate: input => (0, exports.parseHost)(input).isValid || `Could not parse "${input}" as a hostname.`,
        },
        {
            name: 'database',
            message: 'What is your database name?',
            validate: input => input.trim() !== '' || 'Database name must not be empty',
        },
        {
            name: 'user',
            message: 'What is the username?',
            validate: input => input.trim() !== '' || 'Username must not be empty',
        },
        {
            name: 'password',
            message: 'What is the password?',
            type: 'password',
        },
        {
            name: 'linkTypes',
            message: `Automatically link types based on foreign key relationships using @materializer` +
                `\n ${chalk.dim('(https://stepzen.com/docs/features/linking-types)')}`,
            type: 'confirm',
            default: false,
        },
    ];
    if (dbType === 'postgresql') {
        questions = questions.concat([
            {
                name: 'schema',
                message: 'What is your database schema (leave blank to use defaults)?',
            },
        ]);
    }
    return inquirer.prompt((0, helpers_1.overrideDefaults)(questions, defaultAnswers));
};
exports.askSqlQuestions = askSqlQuestions;
const sql2sdl = async (dbType, { name, source, host, database, user, password, linkTypes, include, schema, onConflict, }, configuration) => {
    let inludeAsTableOptions;
    switch (include) {
        case 'tables-only':
            inludeAsTableOptions = 'ONLYTABLES';
            break;
        case 'views-only':
            inludeAsTableOptions = 'ONLYVIEWS';
            break;
        case 'tables-and-views':
            inludeAsTableOptions = 'TABLESANDVIEWS';
            break;
        default:
            inludeAsTableOptions = null;
    }
    const effectiveName = name || dbType;
    const hostDetails = (0, exports.parseHost)(host);
    const response = await (0, helpers_1.queryIntrospectionService)((0, configuration_1.getDBIntrospectionUrl)(configuration), {
        operation: 'generateSDL',
        variables: {
            driver: {
                type: 'DBDriver!',
                value: dbType === 'mysql' ? 'MYSQL' : 'POSTGRESQL',
            },
            host: {
                type: 'String!',
                value: hostDetails.host,
            },
            port: {
                type: 'Int',
                value: hostDetails.port === undefined
                    ? null
                    : parseInt(hostDetails.port, 10),
            },
            database: {
                type: 'String!',
                value: database,
            },
            user: {
                type: 'String!',
                value: user,
            },
            password: {
                type: 'String!',
                value: password,
            },
            onlyTypes: {
                type: 'Boolean',
                value: !linkTypes,
            },
            include: {
                type: 'TableOptions',
                value: inludeAsTableOptions,
            },
            schema: {
                type: 'String',
                // The introspection service treats the schema value '' (empty string)
                // as 'all schemas'. In order to get the introspection service to use
                // the default, it needs to get a `null` schema value.
                // However, when the user skips over the "schema" interactive question
                // (by pressing <Enter>) the value of schema would be ''.
                value: schema === '' ? null : schema,
            },
            configName: {
                type: 'String!',
                value: `${effectiveName}_config`,
            },
        },
    });
    if (response.error) {
        return { error: response.error };
    }
    return (0, helpers_1.writeSdlAndConfig)({
        name: effectiveName,
        source,
        mergeTypes: true,
        onConflict,
        response,
    });
};
exports.sql2sdl = sql2sdl;
//# sourceMappingURL=sql2sdl.js.map